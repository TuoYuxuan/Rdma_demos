# RDMA Demo 示例

本目录包含基于 RDMA 的四种通信方式（send/read/write/atomic）的简单示例程序。

## RDMA 四种通信方式

RDMA（Remote Direct Memory Access）提供了四种主要的通信方式，每种方式都有其独特的特点和适用场景：

### 1. Send/Recv 操作

**工作原理：**
- 基于消息传递模型，需要发送方和接收方配合
- 数据到达时会触发接收完成事件

**特点：**
- 双边操作（需要两端协作）
- 支持立即数（Immediate Data）
- 目标端需要CPU参与处理
- 适合小消息和控制信息传输

**应用场景：**
- 握手协议和控制消息
- 小数据量的请求-响应模式
- 需要目标端感知的通信

### 2. RDMA Write 操作

**工作原理：**
- 单边操作，发送方直接写入远程内存
- 不需要接收方预先准备接收缓冲区
- 发送方需要知道远程内存的地址和权限密钥(rkey)
- 写操作完成后可选择性地发送立即数通知接收方

**特点：**
- 单边操作（只需发送方参与）
- 零拷贝，绕过目标端CPU
- 高带宽、低延迟
- 支持 Write with Immediate

**应用场景：**
- 大数据传输
- 数据复制和备份
- 分布式存储系统
- 高频交易数据推送

### 3. RDMA Read 操作

**工作原理：**
- 单边操作，发送方从远程内存读取数据
- 发送方需要远程内存的地址和读权限
- 读取的数据直接写入本地指定的内存区域
- 操作完成后触发本地完成事件

**特点：**
- 单边操作，远程端无感知
- 拉取模式的数据获取
- 可能受到远程端outstanding reads限制
- 需要往返时间，延迟相对较高

**应用场景：**
- 按需数据获取
- 分布式数据库查询
- 远程监控和状态检查
- 负载均衡中的数据拉取

### 4. Atomic 操作

**工作原理：**
- 允许远程节点对本地内存执行原子读-修改-写操作
- 硬件保证操作的原子性
- 操作结果（原始值）返回给发起方

**特点：**
- 硬件级原子性保证
- 固定8字节操作大小
- 单次网络往返完成复杂操作
- 支持高并发无锁编程

**应用场景：**
- 分布式锁实现
- 原子计数器
- 无锁数据结构
- 分布式协调服务

## 性能对比

| 操作类型 | CPU参与 | 网络往返 | 延迟 | 带宽 | 适用数据量 |
|---------|---------|----------|------|------|-----------|
| Send/Recv | 双端 | 1 | 中等 | 高 | 小到大 |
| RDMA Write | 单端 | 1 | 低 | 最高 | 大 |
| RDMA Read | 单端 | 1 | 中等 | 高 | 中到大 |
| Atomic | 单端 | 1 | 低 | 低 | 固定8字节 |

## 内存权限要求

不同操作需要在注册内存时设置相应的访问权限：

```c
// Send/Recv操作
flags = IBV_ACCESS_LOCAL_WRITE;

// RDMA Write操作
flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE;

// RDMA Read操作
flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ;

// Atomic操作
flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_ATOMIC;
```

## 使用建议

1. **Send/Recv**: 适合控制消息、小数据传输、需要接收端感知的场景
2. **RDMA Write**: 适合大数据推送、流式传输、单向数据复制
3. **RDMA Read**: 适合按需数据获取、查询操作、数据同步
4. **Atomic**: 适合分布式同步、计数器、无锁编程

选择合适的通信方式对于实现高性能的RDMA应用至关重要。
